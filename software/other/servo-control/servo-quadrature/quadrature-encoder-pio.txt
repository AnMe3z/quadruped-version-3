Funkcii:
	1. PIO programata trqbva da moze da broi 'promenite' na state-a						|	UGUL + POSOKA
		* posle v samiq procesor shte se vzimat promenite i shte se umnozavat po uglovata stupka
	2. Skorost?
		* posle v samata programa moze da se izgradi interupt koito da broi vremeto mezdu imeneniqta na stoinostta ot PIO programata
Sentenciq:

	int QEM [16] = {0,1,-1,2,-1,0,2,1,1,2,0,-1,2,-1,1,0}; 
	oldState = newState;
	newState = gpio_get(QUADRATURE_A_PIN)*2 + gpio_get(QUADRATURE_B_PIN);
	steps += QEM[oldState*4+newState];
	
	
.program quadrature-encoder

;	This program reads a quadrature encoder.
;	The total state changes are counted and then outputted.
;	Consequently you can monitor the direction.
;	There is needed additional computation for total degrees of change of speed of change.
;		NB: This program does not counts the total degrees of change but just the pulses
;		from the hardware of the encoder. 

init:
	set X, 0	;

mainloop:

	jmp mainloop	;
	
	
	
#define	MY_SM	0

#include "my_pio_prog.pio.h"

static void __not_in_flash_func(pio_irq0_handler)(void)
{
    while (!pio_sm_is_rx_fifo_empty(PIO_PWM_CAPTURE, MY_SM))
    {
        	uint32_t fv;

        	fv = pio_sm_get(PIO_PWM_CAPTURE, MY_SM);
		do_something_with(fv);
	}
}

void pio_init(void)
{
    int offset;

    offset = pio_add_program(pio0, &my_pio_prog);

    my_pio_prog_init(pio0, MY_SM, offset);  // Generated by PIOASM
     
    irq_set_exclusive_handler(pio0, pio_irq0_handler);

    // Enable FIFO interrupt in the PIO itself
    pio_set_irq0_source_enabled(pio0,  pis_sm0_rx_fifo_not_empty + MY_SM, true);
     
    // Enable IRQ in the NVIC
    irq_set_enabled(PIO0_IRQ_0, true);
}
